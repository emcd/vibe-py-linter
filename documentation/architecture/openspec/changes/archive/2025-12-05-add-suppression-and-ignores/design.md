## Context
The linter currently enforces rules globally. To enable incremental adoption and handle special cases (like legacy code or test files), we need granular control over where rules are applied.

## Decisions

### Decision: Per-File Ignores in Configuration
We will add a `per-file-ignores` table to `[tool.vibelinter]`. Keys will be glob patterns (relative to project root) and values will be lists of rule codes to ignore.

**Example:**
```toml
[tool.vibelinter.per-file-ignores]
"tests/**/*.py" = ["VBL101", "VBL201"]
"legacy/module.py" = ["VBL001"]
```

### Decision: Inline Suppression via `# noqa`
We will adopt the standard `# noqa` comment syntax used by Flake8 and Ruff.
- `# noqa` (ignores all rules on line)
- `# noqa: CODE1,CODE2` (ignores specific rules)

### Decision: Filtering Strategy
Violations will be generated by the engine as usual. A new filtering step `filter_violations` will be applied before returning the report. This step will check:
1. **Per-file ignores**: Check if file path matches any ignore pattern for the violation's rule.
2. **Inline suppression**: Check if the violation line has a corresponding `noqa` comment.

## Trade-offs
- **Performance**: Parsing comments for every line might add overhead. We will optimize by only checking lines with violations.
- **Complexity**: Glob matching for every file/rule combination. We can cache compiled globs or match results per file.
