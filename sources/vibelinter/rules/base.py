# type: ignore
# vim: set filetype=python fileencoding=utf-8:
# ruff: noqa: E501, TRY003

# -*- coding: utf-8 -*-

#============================================================================#
#                                                                            #
#  Licensed under the Apache License, Version 2.0 (the "License");           #
#  you may not use this file except in compliance with the License.          #
#  You may obtain a copy of the License at                                   #
#                                                                            #
#      http://www.apache.org/licenses/LICENSE-2.0                            #
#                                                                            #
#  Unless required by applicable law or agreed to in writing, software       #
#  distributed under the License is distributed on an "AS IS" BASIS,         #
#  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.  #
#  See the License for the specific language governing permissions and       #
#  limitations under the License.                                            #
#                                                                            #
#============================================================================#


''' Base rule framework implementing collection-then-analysis pattern. '''

# pyright: reportIncompatibleMethodOverride=false

import abc

from . import __


class BaseRule( __.libcst.CSTVisitor ):
    ''' Abstract base class for linting rules implementing collection-then-analysis pattern.

        Rules collect data during CST traversal and perform analysis in leave_Module to
        generate violations. This pattern supports complex rules requiring complete
        information before analysis can occur.

        Note: Cannot inherit from abc.ABC due to metaclass conflict with CSTVisitor.
        However, @abc.abstractmethod decorators still enforce abstract method requirements.
    '''

    METADATA_DEPENDENCIES = (
        __.libcst.metadata.PositionProvider,
        __.libcst.metadata.ScopeProvider,
        __.libcst.metadata.QualifiedNameProvider,
    )

    def __init__(
        self,
        filename: __.typx.Annotated[
            str, __.ddoc.Doc( 'Path to source file being analyzed.' ) ],
        wrapper: __.typx.Annotated[
            __.libcst.metadata.MetadataWrapper,
            __.ddoc.Doc( 'LibCST metadata wrapper providing position and scope information.' ) ],
        source_lines: __.typx.Annotated[
            tuple[ str, ... ], __.ddoc.Doc( 'Source file lines for context extraction.' ) ],
    ) -> None:
        super( ).__init__( )
        self.filename = filename
        self.wrapper = wrapper
        self.source_lines = source_lines
        self._violations: list[ __.violations.Violation ] = [ ]

    @property
    @abc.abstractmethod
    def rule_id( self ) -> __.typx.Annotated[
        str, __.ddoc.Doc( 'Unique identifier for rule (VBL code).' ) ]:
        ''' Returns the VBL code for this rule. '''

    @property
    def violations( self ) -> tuple[ __.violations.Violation, ... ]:
        ''' Returns violations generated by rule analysis. '''
        return tuple( self._violations )

    def leave_Module(
        self, node: __.libcst.Module
    ) -> __.typx.Optional[ __.libcst.Module ]:
        ''' Performs collection analysis after CST traversal completes.

            Subclasses must override _analyze_collections to implement rule-specific
            analysis logic using collected data.
        '''
        self._analyze_collections( )
        return node

    @abc.abstractmethod
    def _analyze_collections( self ) -> None:
        ''' Analyzes collected data and generates violations.

            Called by leave_Module after traversal completes. Implementations
            should examine collected data and call _produce_violation for
            any violations discovered.
        '''

    def _produce_violation(
        self,
        node: __.typx.Annotated[
            __.libcst.CSTNode, __.ddoc.Doc( 'CST node where violation occurred.' ) ],
        message: __.typx.Annotated[
            str, __.ddoc.Doc( 'Human-readable violation description.' ) ],
        severity: __.typx.Annotated[
            str, __.ddoc.Doc( "Severity level: 'error', 'warning', or 'info'." ) ] = 'error',
    ) -> None:
        ''' Creates violation from CST node with precise positioning. '''
        line, column = self._position_from_node( node )
        violation = __.violations.Violation(
            rule_id = self.rule_id,
            filename = self.filename,
            line = line,
            column = column,
            message = message,
            severity = severity,
        )
        self._violations.append( violation )

    def _extract_context(
        self,
        line: __.typx.Annotated[ int, __.ddoc.Doc( 'One-indexed line number.' ) ],
        context_size: __.typx.Annotated[
            int, __.ddoc.Doc( 'Number of lines to show before and after violation.' ) ] = 2,
    ) -> __.violations.ViolationContext:
        ''' Extracts source code context around violation for enhanced reporting. '''
        # Calculate context range
        start_line = max( 1, line - context_size )
        end_line = min( len( self.source_lines ), line + context_size )

        # Extract context lines (convert to 0-indexed for array access)
        context_lines = tuple(
            self.source_lines[ i ]
            for i in range( start_line - 1, end_line )
        )

        # Find the violation in _violations list to create ViolationContext
        # This is a helper method, so we assume the violation was just created
        if self._violations:
            violation = self._violations[ -1 ]
            return __.violations.ViolationContext(
                violation = violation,
                context_lines = context_lines,
                context_start_line = start_line,
            )
        # Should not happen in normal usage, but handle gracefully
        raise __.immut.exceptions.Omnierror(
            'Cannot extract context without a violation' )

    def _position_from_node(
        self, node: __.libcst.CSTNode
    ) -> tuple[ int, int ]:
        ''' Extracts (line, column) position from CST node using metadata.

            Returns one-indexed line and column numbers for consistency.
        '''
        try:
            position = self.wrapper.resolve( __.libcst.metadata.PositionProvider )[ node ]
            # LibCST provides 1-indexed lines, 0-indexed columns
            # We want 1-indexed for both
            return ( position.start.line, position.start.column + 1 )
        except KeyError:
            # If position is not available, return (1, 1) as fallback
            # This should not happen in normal operation
            return ( 1, 1 )
